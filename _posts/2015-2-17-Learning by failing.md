---
layout: post
title: Learning by failing
tags: [Hack Reactor, Javascript, Ruby, Servers, Learning]
---

While planning our Hack Reactor final project, we ended up pushing ourselves to take on quite a few challenges.  We are working on a music player application that is backed by a Machine Learning recommendation algorithm.  During the scoping phase, we pushed towards learning as much as we could during this period.

One of these choices was the choice to build the back end application server using Ruby on Rails.  As background, it's important to note that Hack Reactor is a full-stack Javascript immersive.  So, for the past eight weeks, we have been intently working on Javascript.  From servers, to front-end, and all manner in between, the focus has been on JS.

These are the lessons we learned by choosing Ruby, and spoiler alert: ultimately switching away for the time being.

<!--more-->

In the group, we all felt that we had a good grasp on what a web server is, what it does and how it's structured.  This gave us the confidence to give Ruby a shot, as we felt it could only strengthen our working knowledge of servers.

Over the course of the last week, we were able to successfully get a Ruby server up and running.  As we moved into the finer details of our application, it became clear that Ruby was adding an extra layer of difficulty to everything we tried to do.

Ruby required a wholly different programming environment, so time was spent setting up tools.

The Ruby server itself also had vastly different directory structure.  It made it very hard to see where things were happening and where to add modules or other pieces of code.  

I think that for me personally, it also reminded me that languages are more than just their syntax.  There is a style and a methodology that goes with it that needs to be accounted for.  

While editing a library written in a different language is achievable, to do the server in Ruby meant that all of the back end would be based in Ruby.  This was a larger problem than we could tackle immediately without risking our overall project.

Now, we are headed to our minimum viable product with a Node.js/Express back end.  Once we get there, we will look at the various pieces and see what we can or should swap out for other technologies.  

I am glad we tried, and glad we got some exposure to Ruby.  We will be better software engineers for it.  

